
### OSI 7 계층에 대해 설명하세요
OSI 7 계층은 인터넷 환경에서 통신하기 위해 네트워킹에 대한 표준을 7 계층으로 나눈 것입니다. 크게 7 계층으로 물리계층, 데이터링크 계층, 네트워크 계층, 전송계층, 세션계층, 표현계층, 응용계층이 있습니다.

- **응용계층**: 사용자에게 통신을 위한 서비스를 제공하는 계층
- **표현계층**: 데이터 형식을 정의하는 계층
- **세션계층**: 컴퓨터 간 통신을 위한 세션을 관리하는 계층
- **전송계층**: 데이터의 신뢰성 있는 전송을 담당하는 계층 (TCP, UDP)
- **네트워크 계층**: 패킷을 목적지까지 전달하는 계층 (IP 등)
- **데이터링크 계층**: 물리적 전송과 에러 검출, 흐름 제어를 담당하는 계층
- **물리계층**: 데이터를 전기 신호로 변환하여 전달하는 계층

**추가 질문**

#### 1. OSI 7 계층 모델이 실제 네트워크 설계에 어떤 이점을 제공하나요?
OSI 7 계층 모델은 네트워크 통신을 논리적인 계층으로 분리해 이해하기 쉽게 하고, 각 계층이 서로 독립적으로 동작하게 만들어 동작하게 만들어 개발과 문제 해결을 용이하게 합니다.

- 모듈화: 각 계층이 별도로 가능하므로 특정 계층에서 발생하는 문제를 쉽게 분석하고 수정할 수 있습니다.
- 표준화: 통신 규칙을 명확히 정의해 다른 하드웨어와 소프트웨어가 상호 운영될 수 있게 합니다.
- 프로토콜 간 상호 운용성: 다양한 제조업체의 프로토콜이 서로 다른 환경에서도 호환됩니다.
- 확장성: 네트워크 확장 시 일부 계층을 변경하거나 추가하는 것이 용이합니다.

#### 2. 네트워크 계층에서 라우팅(Routing)의 역할은 무엇인가요?
네트워크 계층에서 라우팅은 패킷이 출발지에서 목적지까지 가장 효율적으로 전달되도록 경로를 결정하는 과정입니다. 라우터는 다양한 경로 중 최적의 경로를 선택해 패킷을 전달합니다.
그 중 주요 역할은 경로 선택, 주소 지정, 네트워크 혼잡 관리가 있습니다.

- 경로 선택(Path Selection): 라우팅 알고리즘을 사용해 네트워크 내에서 최적의 경로를 찾아 패킷을 전송합니다.
- 주소 지정(Addressing): 목적이 IP 주소에 따라 패킷을 올바른 경로로 보내며, 하위 네트워크에서 최종 목적지까지 패킷을 전달합니다.
- 네트워크 혼잡 관리: 트래픽이 많은 구간을 피하거나 대체 경로를 선택해 네트워크의 효율성을 유지합니다.

---

### TCP와 UDP의 차이에 대해 설명하세요
TCP는 연결형 서비스로, 3-way handshaking 과정을 통해 연결을 설정합니다. 이로 인해 높은 신뢰성을 보장하지만 속도가 느릴 수 있습니다. 반면에 UDP는 비연결형 서비스로, 신뢰성이 떨어지지만 속도가 빠릅니다. TCP는 신뢰성이 중요한 파일 전송에 주로 사용되며, UDP는 실시간 전송이 중요한 스트리밍 등에 사용됩니다.

**추가 질문**

#### 1. TCP의 3-way Handshaking 과정이란 무엇인가요?
TCP의 3-way handshaking은 신뢰성 있는 연결을 설정하기 위한 세 단계의 과정입니다. 
첫 번쨰로 클라이언트가 서버에 연결 요청(SYN 패킷)을 보냅니다.
두 번쨰로 서버가 연결 요청을 수락하고 응답 (SYN-ACK 패킷)을 보냅니다.
세 번쨰로 클라이언트가 서버의 응답을 확인하고 ACK 패킷을 보냅니다. 이로써 연결이 확립됩니다!

#### 2. 왜 UDP는 실시간 전송에 더 적합한가요?
UDP는 **비연결성 프로토콜**로, 패킷 손실이나 순서 보장을 위한 추가적인 과정 없이 빠르게 데이터를 전송할 수 있기 때무넹 실시간 전송에 적합합니다. 실시간 전송에서는 속도가 매우 중요하며, 약간의 패킷 손실이나 지연이 발생해도 큰 문제가 되지 않는 경우가 많습니다. 그래서 스트리밍, 온라인 게임 같은 애플리케이션에서는 UDP가 선호됩니다. TCP처럼 연결 설정 과정이나 재전송으로 인한 지연이 없기 때문에 실시간 성능이 더 뛰어납니다.


---

### 3-way handshaking과 4-way handshaking의 차이가 뭐죠?
3-way handshaking은 TCP 네트워크에서 통신하는 장치가 서로 연결을 설정하는 과정입니다. 송신자와 수신자가 3번의 패킷을 주고받아 연결이 성립되었음을 확인합니다.  
4-way handshaking은 TCP 연결을 해제할 때 사용되며, 송신자와 수신자가 4번의 패킷을 주고받으며 연결을 종료합니다.

**꼬리 질문**

#### 1. 왜 TCP 연결 종료 과정에서 4-way handshaking이 필요한가요?
TCP 연결 종료 시 4-way handshaking이 필요한 이유는, 데이터 전송의 양방향 특성 때문입니다. TCP는 양측에서 독립적으로 연결을 종료할 수 있으며, 각각의 방향에서 전송이 완료되었음을 확인해야 합니다.

#### 2. TCP에서 왜 연결 설정 과정(3-way handshaking)과 종료 과정(4-way handshaking)이 서로 다른가요?
3-way handshaking은 송신자와 수신자 모두가 데이터를 주고 받을 준비가 되었음을 확인하는 절차로, 상대방의 준비 상태를 확인 한 후 양방향 연결을 동시에 설정하지만.
4-way handshakign은 양측의 데이터 전송이 개별적으로 완료될 수 있기 때문에, 양방에서 독립적으로 종료해야 합니다. 그래서 한쪽은 먼저 전송을 종료 할 수 있지만 상대방이 아직 데이터를 전송할 필요할 수 있으므로, 종료 과정이 독립적으로 처리됩니다.

---

### Http Method 중 GET과 POST의 차이에 대해 설명하세요
GET은 데이터를 조회하기 위해 사용되며, 데이터를 URL에 포함시켜 전송합니다. 이로 인해 URL에 데이터가 노출될 수 있어 보안에 취약할 수 있습니다. POST는 데이터를 전송할 때 Body에 포함시켜 보내며, 보안성이 필요할 때 주로 사용됩니다.

**꼬리 질문**

#### 1. GET과 POST는 보안 외에 어떤 다른 차이점이 있나요?
캐싱에서의 GET 요청은 브라우저나 프록시 서버에 의해 캐싱될 수 있어서, 같은 요청을 다시 보낼 때 서버에 요청하지 않고 캐시된 데이터를 사용할 수 있습니다. 반면에 POST는 캐싱되지 않습니다.
데이터 전송량에서의 GET은 URL에 데이터를 포함시키기 때문에 전송할 수 있는 데이터 크기가 제한적입니다. 보통 URL 길이가 제한되기 때문입니다. 반면에 POST는 Body에 데이터를 넣기 때문에 전송할 수 있는 데이터 크기 제한이 상대적으로 크지 않습니다.

#### 2. POST 방식이 GET보다 보안성이 높다고 하지만, 완전히 안전한가요?
POST가 GET보다 보안성이 높은 건 맞지만, 완전히 안전한 건 아닙니다.
POST는 데이터를 URL 대신 Body에 담아서 전송하긴 하지만 여전히 HTTPS가 아닌 HTTP로 전송되면 데이터가 평문으로 전송돼서 중간에 가로챌 수 있습니다. 그래서 민감한 정보는 반드시 HTTPS로 암호화된 통신을 통해 전송하는 게 중요합니다. 

---

### Http와 Https의 차이가 뭐죠?
HTTP는 웹 페이지와 같은 자원을 주고받을 때 사용하는 통신 규약입니다. HTTP는 데이터를 평문으로 전송하기 때문에 보안에 취약합니다. 이를 해결하기 위해 HTTPS가 등장했으며, HTTPS는 TLS/SSL 프로토콜을 사용해 데이터를 암호화하여 전송합니다.

**꼬리 질문**

#### HTTPS를 사용하면 모든 보안 문제가 해결되나요?
HTTPS가 데이터를 암호화해주니까 중간에서 가로채는 공격 같은 건 막을 수 있지만 웹사이트 자체에 문제가 있으면(SQL 인젝션이나 XSS 같은 거) HTTPS로는 막을 수 없습니다. 그건 서버나 클라이언트 쪽의 코드 문제라서 다른 보안 방법이 필요하기 때문입니다.
그리고 피싱 사이트가 HTTPS를 쓸 수도 있기 때문에 사이트 자체가 신뢰할 만한지 확인하는 것도 중요합니다.

---

### 세션 기반 인증과 토큰 기반 인증의 차이에 대해 설명하세요
세션 기반 인증은 서버가 클라이언트의 상태를 저장하는 방식으로, Stateful한 구조를 가집니다. 반면에 토큰 기반 인증은 상태 정보를 클라이언트가 저장하며, 서버는 Stateless한 구조를 갖습니다.

**꼬리 질문**
#### 1. 세션 기반 인증과 토큰 기반 인증의 장단점은 무엇인가요?
세션 기반 인증의 장점으로는 세션 정보를 서버에서 관리하기 때문에 보안성이 높고, 서버에서 직접 세션을 무효화할 수 있습니다. 그리고 클라이언트의 요청마다 상태 정보를 서버에서 쉽게 추적할 수 있습니다.
단점으로는 세션 정보를 서버에 저장해야 하므로, 사용자가 많아질수록 서버에 부담이 가중될 수 있고, 여러 서버에서 세션을 공유해야 하므로, 클러스터 환경에서 관리가 복잡해질 수 있습니다.

토큰 기반 인증의 장점으로는 서버가 클라이언트의 상태를 저장하지 않기 때문에 서버 확장성이 좋고, 부하 분산이 용이합니다. 그리고 모바일 앱, 웹 앱 등 다양한 플랫폼에서 쉽게 사용이 가능합니다.
다만 단점으로는 토큰이 유출되면, 서버에서 해당 토큰을 무효화하지 않는 한 누구든지 접근이 가능합니다. 클라이언트 측에서 상태 정보를 관리해야 하므로, 추가적인 로직이 필요할 수 있습니다.

---

### JWT 토큰에 대해 설명하세요
JWT는 JSON 포맷을 사용하여 클레임 기반으로 정보를 저장하는 웹 토큰입니다. JWT는 헤더, 페이로드, 서명으로 구성되며, 각 파트는 점(.)으로 구분됩니다.

**꼬리 질문**

#### 1. JWT의 각 구성 요소인 헤더, 페이로드, 서명의 역할은 무엇인가요?

JWT는 세 가지 주요 구성 요소로 이루어져 있습니다. 
첫 번째는 헤더입니다. 헤더는 JWT의 타입과 사용된 서명 알고리즘을 정의하며, 일반적으로 {"alg": "HS256", "typ": "JWT"}와 같은 형식으로 구성됩니다. 
두 번째는 페이로드입니다. 페이로드에는 사용자와 관련된 클레임, 즉 정보를 담고 있습니다. 클레임은 등록된 클레임, 공개 클레임, 비공개 클레임으로 나뉘며, 예를 들어 사용자 ID나 만료 시간 등의 정보가 포함될 수 있습니다. 
마지막으로 서명이 있습니다. 서명은 헤더와 페이로드를 기반으로 비밀 키를 사용하여 생성됩니다. 이 서명은 데이터의 무결성과 인증을 보장하며, 토큰이 위조되지 않았음을 확인하는 데 중요한 역할을 합니다.

#### 2. JWT를 사용할 때의 장점은 무엇인가요?

JWT를 사용할 때의 장점은 여러 가지가 있습니다. 우선, JWT는 자체적으로 인증할 수 있는 구조를 가지고 있어, 서버가 상태를 저장할 필요가 없습니다. 이로 인해 서버의 부하를 줄이고 확장성을 높일 수 있는 장점이 있습니다. 
또한, JWT는 Cross-Domain 지원이 가능하여 웹과 모바일 환경 모두에서 쉽게 사용할 수 있습니다. 다양한 플랫폼 간의 인증을 용이하게 해줍니다. 마지막으로, JWT는 보안성이 높습니다. 
서명된 JWT는 데이터의 무결성을 보장하여, 중간에서 데이터가 변경되지 않았음을 확인할 수 있어 보안적인 측면에서도 유리합니다.
- Cross-Domain: 서로 도메인 간의 상호작용을 의미

---

### OAuth에 대해 설명하세요
OAuth는 외부 서비스에서 사용자 자원에 대한 제한된 접근 권한을 허용하는 인증 표준 프로토콜입니다. 사용자는 자신의 자격 증명을 제공하지 않고도, 외부 서비스에 제한된 권한을 위임할 수 있습니다. 예를 들어, 소셜 로그인을 통해 카카오톡 계정으로 다른 서비스에 로그인하는 방식이 OAuth의 대표적인 사용 예입니다.

**꼬리 질문**
#### 1. OAuth의 동작 방식은 어떻게 되나요?

OAuth는 사용자 인증 및 권한 위임을 위해 여러 단계를 거쳐 동작합니다. 우선 사용자가 애플리케이션에 접근하려고 하면, 애플리케이션은 OAuth 프로바이더에게 인증 요청을 보냅니다. 이 요청에는 사용자에게 어떤 자원에 접근할지를 명시합니다. 
그 다음, 사용자는 OAuth 프로바이더(예: 구글, 카카오 등)에서 자신의 자격 증명을 입력하고, 애플리케이션이 요청한 권한을 허용합니다. 이때 프로바이더는 애플리케이션에 액세스 토큰을 반환합니다. 
이 액세스 토큰은 애플리케이션이 사용자 자원에 접근할 때 사용되며, 이를 통해 사용자는 자신의 자격 증명을 직접 제공하지 않고도 안전하게 외부 서비스에 로그인하거나 데이터를 공유할 수 있습니다.

#### 2. OAuth의 장점과 단점은 무엇인가요?

OAuth의 장점 중 하나는 사용자에게 보안성을 제공한다는 것입니다. 사용자는 자신의 비밀번호를 애플리케이션에 입력하지 않고도 인증할 수 있어, 자격 증명이 노출될 위험이 줄어듭니다. 또한, 사용자가 권한을 세밀하게 조정할 수 있어, 특정 자원에 대한 접근만 허용하거나 필요할 때 권한을 철회할 수 있습니다. 또 다른 장점은 사용자 경험을 개선하는 것입니다. 소셜 로그인을 통해 여러 서비스에 간편하게 로그인할 수 있어 사용자들이 번거롭게 여러 계정을 관리할 필요가 없습니다.
하지만 OAuth의 단점도 존재합니다. 첫째로, 구현이 복잡할 수 있다는 점입니다. OAuth 프로토콜은 다양한 단계와 권한 부여 방식을 포함하고 있어, 개발자가 이를 정확히 이해하고 구현하는 데 어려움을 겪을 수 있습니다. 둘째로, 액세스 토큰이 탈취될 경우 보안 위험이 발생할 수 있습니다. 만약 토큰이 유출되면 악의적인 사용자가 사용자 자원에 접근할 수 있는 위험이 있기 때문에, 이를 관리하는 것이 중요합니다. 

---

### 웹 브라우저로 www.naver.com에 접속하면 일어나는 일을 설명하세요
사용자가 브라우저 주소창에 www.naver.com을 입력하면, DNS 서버에 도메인 네임을 전달해 해당 도메인에 대응하는 IP 주소를 받아옵니다. 이 IP 주소를 기반으로 서버에 TCP 요청을 보내고, 서버는 클라이언트에게 HTTP 응답을 전송합니다. 브라우저는 받은 데이터를 렌더링하여 웹 페이지를 사용자에게 보여줍니다.

**꼬리 질문**
#### 1. DNS가 없는 경우, 웹 브라우저는 어떻게 동작할까요?

DNS가 없다면, 사용자는 IP 주소를 직접 입력해야 웹사이트에 접속할 수 있습니다. 예를 들어, 사용자가 192.168.0.1와 같은 IP 주소를 입력하면 브라우저는 해당 주소에 직접 요청을 보낼 수 있지만, 이는 사용자에게 매우 불편하고 비효율적입니다. 
또한, IP 주소가 변경될 경우 사용자가 다시 기억해야 하므로 접근성이 떨어집니다. DNS는 이러한 불편함을 해결하고, 도메인 이름을 쉽게 기억할 수 있도록 도와주는 중요한 역할을 합니다.

#### 2. 브라우저가 웹 페이지를 렌더링하는 과정은 어떻게 되나요?

브라우저가 웹 페이지를 렌더링하는 과정은 여러 단계로 나뉘어집니다. 먼저, 브라우저는 서버로부터 받은 HTML 문서를 분석합니다. 
이 HTML 문서에는 CSS와 JavaScript 파일에 대한 링크가 포함되어 있을 수 있습니다. 브라우저는 이 파일들을 추가로 요청하고, 다운로드한 후에는 CSS를 적용하여 페이지의 스타일을 설정합니다. 
JavaScript는 페이지의 동작을 제어하고, 필요에 따라 DOM을 수정하여 사용자와의 상호작용을 가능하게 합니다. 최종적으로, 모든 요소가 결합되어 화면에 표시되며 사용자는 이를 통해 웹 페이지를 경험하게 됩니다.

---

### DNS란 무엇이며, 어떻게 동작하나요?
DNS는 Domain Name System의 약자로, 사람이 이해하기 쉬운 도메인 이름(www.example.com)을 컴퓨터가 이해할 수 있는 IP 주소(192.168.0.1)로 변환해주는 시스템입니다. DNS는 계층 구조로 이루어져 있으며, 클라이언트가 도메인 이름을 입력하면 브라우저는 DNS 서버에 해당 도메인 이름에 대한 IP 주소를 요청하고, 해당 IP 주소를 받아와 웹사이트에 접속합니다.

**꼬리 질문**
#### 1. DNS의 주요 구성 요소는 무엇인가요?

DNS의 주요 구성 요소는 다음과 같습니다. 첫째, DNS 레코드입니다. 이 레코드는 도메인 이름과 IP 주소를 매핑하는 정보로, 다양한 유형의 레코드(A, AAAA, CNAME 등)가 존재합니다. 
둘째, DNS 서버입니다. DNS 서버는 도메인 이름을 IP 주소로 변환하는 기능을 수행하며, 주로 루트 DNS 서버, 권한 있는 DNS 서버, 로컬 DNS 서버로 구분됩니다. 
셋째, 도메인 네임 레지스트리입니다. 이는 특정 도메인 이름에 대한 소유권을 관리하고, 도메인이 DNS 서버에 등록되도록 돕습니다. 이 모든 요소가 함께 작용하여 DNS가 원활하게 동작하도록 합니다.

#### 2. DNS 캐싱이란 무엇인가요?

DNS 캐싱은 DNS 서버나 클라이언트 브라우저가 DNS 조회 결과를 임시로 저장하는 과정을 말합니다. 
이를 통해 동일한 도메인에 대한 후속 요청 시 DNS 조회를 생략하고, 저장된 정보를 통해 더 빠르게 IP 주소를 반환할 수 있습니다. 
이렇게 캐싱이 이루어지면, 네트워크 대역폭을 절약하고 DNS 요청 처리 속도를 높일 수 있습니다. 하지만, DNS 레코드가 변경되었을 때 캐시된 정보가 오래 남아있으면 잘못된 IP 주소로 연결될 수 있으므로, 캐시 만료 시간을 적절히 설정하는 것이 중요합니다.

---

### Subnetting(서브넷팅)이란 무엇인가요?
서브넷팅은 하나의 IP 주소 블록을 여러 개의 작은 네트워크로 나누는 과정입니다. IP 주소를 네트워크와 호스트 부분으로 나누어, 네트워크 트래픽을 분리하고 보안성을 높일 수 있습니다. 또한, IP 주소 공간을 효율적으로 사용하고 네트워크 성능을 최적화하는 데 사용됩니다.

**꼬리 질문**
#### 1. 서브넷팅의 주요 장점은 무엇인가요?

서브넷팅의 주요 장점은 여러 가지가 있습니다. 첫째, 효율적인 IP 주소 관리입니다. 서브넷팅을 통해 IP 주소 공간을 보다 효율적으로 사용하고, 필요에 따라 주소를 재분배할 수 있습니다. 
둘째, 네트워크 보안 향상입니다. 서로 다른 서브넷 간의 트래픽을 분리함으로써, 한 네트워크에서 발생한 보안 사고가 다른 네트워크로 확산되는 것을 방지할 수 있습니다. 
셋째, 네트워크 성능 개선입니다. 서브넷팅을 통해 네트워크 트래픽을 분산시키고, 혼잡을 줄여 성능을 최적화할 수 있습니다.

#### 2. 서브넷 마스크란 무엇인가요?

서브넷 마스크는 IP 주소의 네트워크 부분과 호스트 부분을 구분하기 위해 사용되는 값입니다. 서브넷 마스크는 보통 32비트로 구성되며, 각 비트는 네트워크와 호스트의 구성을 나타냅니다. 
예를 들어, 서브넷 마스크가 255.255.255.0이라면, 이 마스크는 첫 세 개의 옥텟(24비트)이 네트워크를 나타내고, 마지막 옥텟(8비트)이 호스트를 나타낸다는 의미입니다. 서브넷 마스크를 사용하여 네트워크의 크기를 정의하고, 특정 서브넷에 속한 IP 주소를 관리할 수 있게 해줍니다.

---

### NAT(Network Address Translation)이란 무엇인가요?
NAT는 사설 네트워크의 여러 장치들이 공인 IP 주소 하나를 사용해 외부 네트워크와 통신할 수 있도록 하는 기술입니다. NAT는 사설 IP 주소를 공인 IP 주소로 변환하고, 이를 통해 내부 네트워크의 IP 주소를 보호하며, 공인 IP 주소의 수를 절약할 수 있습니다.

**꼬리 질문**

#### 1. NAT의 장점은 무엇인가요?

NAT의 가장 큰 장점 중 하나는 IP 주소 보안입니다. NAT를 사용하면 내부 네트워크의 IP 주소가 외부에 노출되지 않기 때문에 해킹 등의 공격으로부터 보호받을 수 있습니다. 
둘째, IP 주소의 절약입니다. 여러 장치가 하나의 공인 IP 주소를 공유함으로써 IP 주소의 사용 효율성을 높일 수 있습니다. 
셋째, NAT는 네트워크 관리를 용이하게 해주며, 내부 네트워크의 구조 변경 없이도 외부와의 통신을 가능하게 하여 유연한 네트워크 구성을 지원합니다.

#### 2. NAT의 단점은 무엇인가요?

NAT의 단점은 일부 프로토콜의 문제입니다. NAT는 TCP/IP 기반의 프로토콜 중 일부, 특히 세션을 유지해야 하는 프로토콜에서 문제가 발생할 수 있습니다. 예를 들어, VoIP와 같은 실시간 통신에서 NAT를 통과하는 과정에서 지연이 발생하거나 연결이 끊길 수 있습니다. 
둘째, NAT는 추적이 어려운 문제를 발생시킬 수 있습니다. 여러 장치가 동일한 공인 IP 주소를 사용하기 때문에 특정 장치의 활동을 추적하는 것이 어렵고, 로그 분석이 복잡해질 수 있습니다.

---

### 대칭키 암호화와 비대칭키 암호화의 차이에 대해 설명하세요
대칭키 암호화는 동일한 키로 데이터를 암호화하고 복호화하는 방식입니다. 암호화 및 복호화 속도가 빠르지만, 키가 노출될 경우 보안이 취약해질 수 있습니다.  
비대칭키 암호화는 공개키로 데이터를 암호화하고, 개인키로 복호화하는 방식입니다. 두 개의 키를 사용하므로 보안성이 높지만, 대칭키 암호화에 비해 속도가 느립니다.

**꼬리 질문**

#### 1. 대칭키 암호화의 예시와 사용 사례는 무엇인가요?

대칭키 암호화의 대표적인 예시는 **AES(Advanced Encryption Standard)**와 **DES(Data Encryption Standard)**입니다. 이들은 강력한 보안성을 제공하며, 주로 데이터 저장, 파일 전송, VPN과 같은 환경에서 사용됩니다. 
예를 들어, 기업에서는 파일 서버에 저장된 기밀 정보를 보호하기 위해 대칭키 암호화를 사용하여 외부 공격으로부터 안전하게 보호합니다.

#### 2. 비대칭키 암호화의 장점과 단점은 무엇인가요?

비대칭키 암호화의 장점은 강력한 보안성입니다. 공개키와 개인키를 사용하므로, 공개키가 유출되어도 개인키가 안전하다면 데이터는 보호받을 수 있습니다. 또한, 비대칭키 암호화는 디지털 서명과 같은 기능을 제공하여 데이터의 무결성과 출처를 확인할 수 있습니다. 
그러나 단점으로는 처리 속도가 느리다는 점이 있습니다. 비대칭키 암호화는 계산이 복잡하기 때문에 대칭키 암호화에 비해 속도가 느리며, 대량의 데이터를 암호화할 때는 비효율적일 수 있습니다.


---

### CDN(Content Delivery Network)이란 무엇인가요?
CDN은 콘텐츠를 사용자에게 빠르게 전달하기 위해 전 세계에 분산된 서버 네트워크입니다. 사용자의 지리적 위치에 가장 가까운 서버에서 콘텐츠를 제공하여 웹사이트 로딩 속도를 향상시키고, 트래픽 부하를 분산시켜 서버 성능을 최적화합니다.

**꼬리 질문**

#### 1. CDN의 장점은 무엇인가요?

CDN의 가장 큰 장점은 속도 향상입니다. 콘텐츠가 사용자와 가까운 서버에서 제공되므로 웹사이트의 로딩 시간이 크게 단축됩니다. 
둘째, 트래픽 부하 분산입니다. 여러 서버에 트래픽을 분산시켜서 특정 서버에 대한 과부하를 방지하고, 안정성을 높입니다. 
셋째, 서버 장애 시의 안정성입니다. 하나의 서버가 다운되더라도 다른 서버를 통해 콘텐츠를 제공할 수 있어, 서비스의 가용성을 높일 수 있습니다.

#### 2. CDN이 필요한 상황은 무엇인가요?

CDN은 대규모 트래픽을 처리해야 하는 웹사이트에서 특히 필요합니다. 예를 들어, 온라인 쇼핑몰, 뉴스 사이트, 동영상 스트리밍 서비스 등은 많은 사용자가 동시에 접속하므로 CDN을 통해 효율적으로 콘텐츠를 전달할 수 있습니다. 또한, 전 세계에 사용자 기반을 둔 서비스에서 지리적 거리로 인한 지연을 줄이기 위해 CDN을 활용하면, 보다 쾌적한 사용자 경험을 제공할 수 있습니다.

---

### 로드 밸런서(Load Balancer)란 무엇인가요?
로드 밸런서는 들어오는 네트워크 트래픽을 여러 서버로 분산하여 서버의 부하를 고르게 나누는 장치입니다. 이를 통해 서버의 과부하를 방지하고, 장애가 발생해도 다른 서버가 요청을 처리할 수 있어 시스템의 가용성과 성능을 높입니다.

**꼬리 질문**
#### 1. 로드 밸런서는 어떤 알고리즘을 사용하여 트래픽을 분산하나요?

로드 밸런서는 트래픽을 효과적으로 분산하기 위해 여러 가지 알고리즘을 사용할 수 있습니다. 대표적인 알고리즘으로는 라운드 로빈(Round Robin), 최소 연결(Least Connections), IP 해시(IP Hash) 등이 있습니다. 라운드 로빈은 들어오는 요청을 순서대로 각 서버에 분배하는 방식으로, 간단하고 효율적입니다. 
최소 연결 알고리즘은 현재 가장 적은 연결 수를 가진 서버에 요청을 보내어 서버의 부하를 고르게 유지합니다. IP 해시는 사용자의 IP 주소를 기반으로 특정 서버에 요청을 할당하여 같은 사용자가 동일한 서버에 연결될 수 있도록 합니다. 이러한 다양한 알고리즘을 통해 로드 밸런서는 트래픽을 효율적으로 관리하고, 서버의 성능을 최적화합니다.

#### 2. 로드 밸런서가 장애 조치(failover) 기능을 제공하는 방법은 무엇인가요?

로드 밸런서는 장애 조치 기능을 통해 시스템의 가용성을 높이는 역할을 합니다. 장애 조치는 주 서버에 문제가 발생했을 때 로드 밸런서가 자동으로 요청을 다른 정상 서버로 전환하여 서비스를 계속 제공하는 기능입니다. 
이를 위해 로드 밸런서는 각 서버의 상태를 지속적으로 모니터링하며, 서버가 응답하지 않거나 특정 조건을 만족하지 않을 경우 해당 서버를 트래픽 분산 목록에서 제외합니다. 이 과정에서 로드 밸런서는 가용성에 영향을 미치지 않도록 대체 서버로 요청을 우회시키며, 사용자에게는 장애가 발생하지 않은 것처럼 서비스를 제공합니다. 
이를 통해 로드 밸런서는 시스템의 신뢰성과 안정성을 유지하는 데 중요한 역할을 합니다.

<br>

---

> JAVA Spring 관련 예상 질문

### Spring에서 RestController와 Controller의 차이에 대해 설명하세요.
Spring에서 **RestController**는 RESTful 웹 서비스를 개발할 때 사용되는 컨트롤러로, 모든 메서드가 기본적으로 JSON 또는 XML 형식으로 데이터를 반환합니다. **Controller**는 주로 템플릿 엔진을 이용한 뷰 렌더링에 사용됩니다. RestController를 사용하면 HTTP 응답을 직접 전달하며, 네트워크를 통해 클라이언트와 JSON 데이터를 주고받는 것이 일반적입니다.

**꼬리 질문**

#### 1. RestController는 언제 사용하나요?

RestController는 RESTful 웹 서비스를 구축할 때 주로 사용됩니다. 이 컨트롤러는 모든 메서드가 JSON 또는 XML과 같은 데이터를 반환하기 때문에, 클라이언트와 서버 간의 데이터 전송이 필요할 때 적합합니다. 예를 들어, 모바일 애플리케이션이나 SPA(Single Page Application)와 같은 클라이언트가 서버와 통신할 때 RESTful API를 통해 데이터를 주고받기 위해 RestController를 사용하는 것이 일반적입니다. 또한, RestController는 HTTP 응답을 직접 반환하므로, 복잡한 뷰 렌더링이 필요하지 않은 경우에도 유용합니다.

#### 2. Controller는 어떤 상황에서 사용되나요?

Controller는 주로 웹 애플리케이션에서 뷰 렌더링을 위한 컨트롤러로 사용됩니다. JSP, Thymeleaf 등의 템플릿 엔진을 활용하여 서버에서 동적으로 HTML 페이지를 생성하고 클라이언트에게 전달하는 경우에 적합합니다. 일반적으로 사용자 인터페이스가 중요한 웹 애플리케이션에서 사용되며, 사용자의 요청을 처리하고, 적절한 뷰를 반환하는 역할을 맡고 있습니다. Controller를 사용하면 사용자 요청에 따라 다양한 템플릿을 렌더링할 수 있어, 더 복잡한 사용자 경험을 제공할 수 있습니다.


---

### Spring에서의 비동기 처리와 네트워크 요청에 대해 설명하세요.
Spring에서는 네트워크 요청을 비동기적으로 처리할 수 있는 다양한 방법을 제공합니다. 예를 들어, `@Async` 어노테이션을 사용하여 메서드를 비동기 처리할 수 있습니다. 비동기 처리는 네트워크 요청이나 긴 작업이 완료될 때까지 쓰레드를 블로킹하지 않으므로 서버 리소스를 효율적으로 사용할 수 있습니다.  
또한 **WebClient**를 사용하여 비동기 방식으로 HTTP 요청을 보내고 응답을 처리할 수 있습니다. 이는 Spring 5부터 제공되는 비동기 및 논블로킹 HTTP 클라이언트입니다.

**꼬리 질문**

#### 1. Spring에서 비동기 처리를 어떻게 구현하나요?

Spring에서는 비동기 처리를 위해 @Async 어노테이션을 사용할 수 있습니다. 이 어노테이션을 메서드에 적용하면, 해당 메서드는 별도의 스레드에서 비동기적으로 실행됩니다. 이렇게 하면 긴 작업이나 네트워크 요청이 완료될 때까지 메인 쓰레드가 블로킹되지 않으므로, 서버의 리소스를 효율적으로 사용할 수 있습니다. 비동기 처리는 특히 대규모 트래픽을 처리하거나 사용자 인터페이스의 응답성을 향상시키는 데 유용합니다. 또한, WebClient를 사용하여 비동기 HTTP 요청을 보내는 방법도 제공되며, 이를 통해 네트워크 통신의 성능을 더욱 높일 수 있습니다.

#### 2. WebClient의 장점은 무엇인가요?

WebClient는 Spring WebFlux에서 도입된 논블로킹 방식의 HTTP 클라이언트로, 비동기적인 HTTP 요청을 처리할 수 있는 장점이 있습니다. WebClient를 사용하면 요청을 보내고 응답을 기다리는 동안 다른 작업을 수행할 수 있으므로, 애플리케이션의 성능을 크게 향상시킬 수 있습니다. 또한, WebClient는 다양한 방식의 요청 및 응답 처리를 지원하며, 리액티브 프로그래밍 패러다임을 따르기 때문에, 데이터 스트림을 효과적으로 처리할 수 있는 기능을 제공합니다. 이러한 점에서 WebClient는 비동기 처리 및 높은 성능을 요구하는 네트워크 통신에서 더 유리합니다.

---

### Spring에서 사용하는 RestTemplate과 WebClient의 차이에 대해 설명하세요.
**RestTemplate**은 Spring에서 HTTP 요청을 동기적으로 처리하는 API입니다. 서버로 요청을 보낸 후 응답이 완료될 때까지 쓰레드를 블로킹하며, 주로 간단한 RESTful 요청에 사용됩니다.  
**WebClient**는 Spring WebFlux에서 도입된 논블로킹 방식의 HTTP 클라이언트로, 비동기적으로 요청을 처리할 수 있습니다. 비동기 처리가 필요하거나 높은 성능을 요구하는 네트워크 통신에서는 WebClient가 더 유리합니다.

**꼬리 질문**

#### 1. RestTemplate은 어떤 상황에서 사용하나요?

RestTemplate은 주로 동기적인 HTTP 요청을 처리할 때 사용됩니다. 간단한 RESTful 요청이나 API 통신을 위해 서버로 요청을 보내고, 응답을 기다리는 방식으로 작동합니다. 
이 방식은 구현이 간단하고, 서버에서의 처리 흐름이 명확할 때 유용하지만, 네트워크 요청이 완료될 때까지 현재 쓰레드가 블로킹되기 때문에 대규모 트래픽 처리에는 적합하지 않습니다. 
따라서 RestTemplate은 상대적으로 단순한 요청 및 응답 처리에 적합하며, 동기 처리가 필요한 경우에 자주 사용됩니다.

#### 2. WebClient가 더 유리한 경우는 언제인가요?

WebClient는 비동기적인 방식으로 HTTP 요청을 처리할 수 있기 때문에, 높은 성능을 요구하거나 비동기 처리가 필요한 상황에서 유리합니다. 
예를 들어, 대량의 데이터 요청이나 여러 API를 동시에 호출해야 하는 경우 WebClient를 사용하면 각 요청을 독립적으로 처리할 수 있어 서버의 리소스를 효율적으로 활용할 수 있습니다. 
또한, WebClient는 논블로킹 방식으로 작동하므로, 응답을 기다리는 동안 다른 작업을 수행할 수 있어 사용자 경험을 개선할 수 있습니다. 이러한 이유로 WebClient는 리액티브 프로그래밍을 기반으로 한 애플리케이션에서 선호됩니다.

---

### WebFlux가 무엇인가요?
Spring WebFlux는 Spring 5에서 도입된 비동기 및 논블로킹 방식의 웹 프레임워크입니다. WebFlux는 Reactive Streams API를 기반으로 하며, 이를 통해 비동기적으로 데이터 스트림을 처리할 수 있습니다. 특히 대규모 네트워크 요청이나 고성능이 요구되는 애플리케이션에서 사용됩니다.

**꼬리 질문**

####  1. WebFlux가 Spring MVC와 다른 점은 무엇인가요?

WebFlux와 Spring MVC의 가장 큰 차이점은 처리 방식에 있습니다. Spring MVC는 전통적인 블로킹 방식으로 동작하여, 각 요청을 처리하는 동안 해당 쓰레드를 블로킹합니다. 반면, WebFlux는 비동기 및 논블로킹 방식으로 동작하여, 요청 처리 중에도 다른 작업을 수행할 수 있도록 합니다. 이러한 비동기 처리 덕분에 WebFlux는 더 높은 동시성을 지원하고, 성능이 뛰어난 애플리케이션을 개발하는 데 적합합니다.


---

### Spring에서의 CORS(Cross-Origin Resource Sharing)란 무엇이며, 어떻게 처리하나요?
CORS는 클라이언트가 브라우저를 통해 다른 도메인의 리소스에 접근하려고 할 때 발생하는 보안 메커니즘입니다.  
Spring에서는 **`@CrossOrigin`** 어노테이션을 사용해 특정 컨트롤러나 메서드에서 CORS 설정을 허용할 수 있습니다. 이를 통해 외부에서 오는 요청에 대한 네트워크 접근을 허용하거나 제한할 수 있습니다.  
또한, **CorsConfiguration** 클래스를 통해 전역적으로 CORS 설정을 할 수도 있습니다.

**꼬리 질문**

#### 1. CORS가 필요한 이유는 무엇인가요?

CORS는 보안 메커니즘으로, 클라이언트가 브라우저를 통해 다른 도메인에서 리소스를 요청할 때 발생하는 문제를 해결하기 위해 필요합니다. 기본적으로 브라우저는 보안을 위해 동일 출처 정책(Same-Origin Policy)을 적용하여, 다른 도메인에서 요청을 차단합니다. 따라서 외부 API나 다른 도메인에 위치한 리소스에 접근하려면 CORS를 설정하여 요청을 허용해야 합니다. CORS를 통해 안전하게 리소스를 공유함으로써, 사용자 경험을 향상시키고 다양한 서비스 통합이 가능해집니다.


---

### 스프링에서 커넥션 풀(Connection Pool)을 사용하는 이유와 이점은 무엇인가요?
네트워크를 통해 데이터베이스나 외부 API에 연결할 때, **커넥션 풀**을 사용하면 성능을 크게 향상시킬 수 있습니다. 커넥션 풀은 미리 생성된 커넥션을 재사용하여, 요청이 발생할 때마다 새로운 네트워크 연결을 생성하는 비용을 절감합니다. Spring에서는 기본적으로 HikariCP를 사용하며, 이를 통해 대규모 트래픽을 처리하는 애플리케이션의 네트워크 성능을 최적화할 수 있습니다.

**꼬리 질문**

#### 1. 커넥션 풀이 없으면 어떤 문제가 발생할 수 있나요?

커넥션 풀이 없으면 데이터베이스에 요청할 때마다 새로운 커넥션을 생성해야 합니다. 이 과정은 많은 시간과 리소스를 소모하게 되며, 특히 동시에 많은 요청이 들어올 경우 성능 저하를 유발할 수 있습니다. 또한, 커넥션을 자주 생성하고 종료하는 것이 반복되면 데이터베이스 서버에 불필요한 부하가 가해져 전체 시스템의 안정성에 부정적인 영향을 미칠 수 있습니다. 이러한 문제로 인해 응답 속도가 느려지고, 서버가 과부하에 시달릴 수 있습니다.

#### 2. HikariCP를 사용하는 이유는 무엇인가요?

HikariCP는 커넥션 풀 라이브러리 중 하나로, 매우 높은 성능과 효율성을 제공합니다. HikariCP를 사용하면 연결이 매우 빠르게 이루어지고, 커넥션 풀 관리가 용이해집니다. 또한, 낮은 오버헤드로 인해 메모리와 CPU 리소스를 효율적으로 사용할 수 있습니다. HikariCP는 다양한 환경에서 최적화되어 있어, 대규모 트래픽이 발생하는 애플리케이션에서 특히 유리합니다. 이를 통해 애플리케이션의 응답성을 높이고, 안정적인 데이터베이스 연결을 보장할 수 있습니다.